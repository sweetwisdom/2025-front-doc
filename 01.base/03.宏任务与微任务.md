在 JavaScript 中，执行顺序受到 **宏任务**（Macrotasks）、**微任务**（Microtasks）和**同步代码**的影响。我们可以通过事件循环机制来理解它们的执行顺序。下面的解释可以帮助你更清楚地了解它们是如何执行的：

### 1. **同步代码（Synchronous Code）**

同步代码会立即执行，且会阻塞后续的代码执行。它的执行是按照代码的顺序逐行进行的。

### 2. **宏任务（Macrotasks）**

宏任务是 JavaScript 中的一类任务，包括：

- `setTimeout`
- `setInterval`
- I/O 操作（比如网络请求）
- `UI 事件`（如点击、键盘输入等）

宏任务会被放入 **宏任务队列**，并且每次事件循环会依次执行这些宏任务。

### 3. **微任务（Microtasks）**

微任务是一类优先级更高的任务，通常在宏任务执行完之前执行。微任务主要包括：

- `Promise` 的 `then`、`catch`、`finally` 回调
- `MutationObserver` 等

微任务会被放入 **微任务队列**，它们会在当前宏任务执行结束后，**立即**执行。

### 执行顺序：事件循环（Event Loop）

JavaScript 是单线程的，所有的代码都在一个执行线程中运行。事件循环的工作原理如下：

1. 执行同步代码：先执行所有的同步任务。
2. 执行微任务：执行所有的微任务（**所有微任务在当前宏任务执行完后执行，且是立即执行的**）。
3. 执行宏任务：执行下一个宏任务，通常是从宏任务队列中取出第一个任务执行。

### **执行顺序的总结：**

1. 执行同步代码
2. 执行微任务队列中的所有微任务（微任务优先级高于宏任务）
3. 执行下一个宏任务（从宏任务队列中取出第一个任务执行）

### 举个例子来帮助理解：

```javascript
console.log('Sync 1');  // 同步任务 1

setTimeout(() => {      // 宏任务 1
  console.log('Macrotask 1');
}, 0);

Promise.resolve().then(() => {  // 微任务 1
  console.log('Microtask 1');
});

console.log('Sync 2');  // 同步任务 2
```

**执行顺序分析：**

1. 首先，执行同步代码，输出 `Sync 1`。
2. 执行 `setTimeout()`，它被加入宏任务队列。
3. 执行 `Promise.resolve().then()`，它被加入微任务队列。
4. 然后执行同步代码 `console.log('Sync 2')`，输出 `Sync 2`。
5. 执行完同步代码后，事件循环会执行微任务队列中的任务，输出 `Microtask 1`。
6. 最后，执行宏任务队列中的第一个任务 `setTimeout()`，输出 `Macrotask 1`。

**最终输出顺序：**

```
Sync 1
Sync 2
Microtask 1
Macrotask 1
```

### **关键点总结：**

- **同步代码** 会立即执行。
- **微任务** 会在当前同步任务执行完毕后、宏任务之前执行。
- **宏任务** 在微任务执行完之后才会执行。

### **特殊情况：**

- 如果有多个微任务，它们会按照加入微任务队列的顺序依次执行。
- 即使你设置 `setTimeout` 的延时为 `0`，它仍然会被视为宏任务，并在所有微任务执行完后执行。

在 JavaScript 中，任务分为三种类型：同步任务（Synchronous Tasks）、宏任务（Macrotasks）和微任务（Microtasks）。

1. **同步代码（Synchronous Code）**：
  - 同步代码是指按照顺序执行的代码，执行过程中会阻塞后续代码的执行，直到当前代码块执行完毕才会执行下一段代码。
  - 典型的同步代码包括函数调用、变量声明、赋值操作等。例如，`console.log()`、`var x = 5;` 等语句都是同步代码。

2. **宏任务（Macrotasks）**：
  - 宏任务是指由 JavaScript 引擎或者宿主环境（如浏览器）提供的任务，它会在当前执行栈执行完毕后立即执行，因此它的执行时间是相对较长的。
  - 典型的宏任务包括定时器任务（setTimeout、setInterval）、事件监听器（addEventListener）、I/O 操作（文件读写、网络请求）等。
  - 宏任务之间存在优先级，通常浏览器会优先执行用户交互相关的任务，如点击事件处理、键盘事件处理等。

3. **微任务（Microtasks）**：
  - 微任务是指由 JavaScript 引擎提供的任务，它会在当前任务执行完毕后立即执行，优先级高于宏任务。
  - 典型的微任务包括 Promise 的 then 回调、MutationObserver 的回调等。
  - 微任务通常用于处理异步操作的结果，如 Promise 的状态变化、DOM 变化等。

当执行 JavaScript 代码时，它会被分为一个个任务，这些任务根据其类型会被放入不同的任务队列中。当主线程空闲时，会从任务队列中取出任务执行。具体来说：

- 当执行同步代码时，会立即执行，直到执行完毕。
- 当执行宏任务时，会将宏任务放入宏任务队列中，等待主线程空闲时执行。
- 当执行微任务时，会将微任务放入微任务队列中，等待主线程当前任务执行完毕后执行。

在事件循环（Event Loop）中，主线程会不断地从宏任务队列中取出一个宏任务执行，然后执行完宏任务后，会依次执行微任务队列中的所有微任务。这个过程会不断重复，直到所有任务都被执行完毕。